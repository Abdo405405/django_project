import django_filters
from .models import Product ,ProductFeedback,STATUS 
from rest_framework.exceptions import ValidationError

class ProductsFilter(django_filters.FilterSet):
    category_name = django_filters.CharFilter(field_name="category__title",lookup_expr="icontains" )
    category_id = django_filters.CharFilter(field_name="category__id",lookup_expr="exact" )
    subcategory_id = django_filters.CharFilter(field_name="subcategory__parent_category_id",lookup_expr="exact" )
    subcategory_name = django_filters.CharFilter(field_name="subcategory__title",lookup_expr="icontains" )
    max_price= django_filters.NumberFilter(field_name="price" ,lookup_expr="lte" )
    min_price= django_filters.NumberFilter(field_name="price",lookup_expr="gte")
    min_year= django_filters.NumberFilter(field_name="created_at__year" , lookup_expr="gte")
    max_year= django_filters.NumberFilter(field_name="created_at__year" , lookup_expr="lte")
    product_status=django_filters.ChoiceFilter(choices=STATUS,lookup_expr="iexact")
    color=django_filters.CharFilter(field_name="color",lookup_expr="icontains" )
    title=django_filters.CharFilter(field_name="title",lookup_expr="icontains" )
    vendor=django_filters.CharFilter(field_name="vendor",lookup_expr="exact" )
    sort_by = django_filters.OrderingFilter(
        fields=(
            ('created_at', 'created_at'),
        ),
        field_labels={
            'created_at': 'Created Date'
        }
    )
    class Meta: 
        model = Product 
        fields = ["min_year","max_year","instock","product_status","Shipping_Fee","min_price","max_price","color","title","subcategory_name","subcategory_id","category_name","category_id","vendor","is_new","rating" ,"sort_by"]
    def filter_queryset(self, queryset):
        queryset = super().filter_queryset(queryset) # you ensure that any default behavior or processing defined in the parent class is applied to the queryset before you perform any additional filtering or modifications in the child class.
        # Check if any field has an empty value
        for field_name, value in self.data.items():
            # Exclude 'csrfmiddlewaretoken' and 'page' fields csrfmiddlewaretoken' or 'page'. These are typically internal fields generated by Django and are not relevant for filtering.
            if (field_name not in ['csrfmiddlewaretoken', 'page'] and field_name not in self.Meta.fields) or  not value: 
                    raise ValidationError("invaild url")  # If any field is empty or field name is wrong , return an empty queryset
        # If all fields have values, return the filtered queryset
            if field_name == 'instock' or field_name == 'is_new' : # Adjust the field names as per your model
                if value.lower() in ["true", "1", "yes", "y"]:
                     queryset = queryset.filter(**{field_name: True})
                elif value.lower() in ["false", "0", "no", "n"]:
                     queryset = queryset.filter(**{field_name: False})
                else:
                     
                     raise ValidationError("invaild url")
                    
                 

        return queryset
    

class FeedbackFilter (django_filters.FilterSet):
     created_at_min_year= django_filters.NumberFilter(field_name="created_at__year" , lookup_expr="gte")
     created_at_max_year= django_filters.NumberFilter(field_name="created_at__year" , lookup_expr="lte")
     created_at_min_month= django_filters.NumberFilter(field_name="created_at__month" , lookup_expr="gte")
     created_at_max_month= django_filters.NumberFilter(field_name="created_at__month" , lookup_expr="lte")
     created_at_min_day= django_filters.NumberFilter(field_name="created_at__day" , lookup_expr="gte")
     created_at_max_day= django_filters.NumberFilter(field_name="created_at__day" , lookup_expr="lte")
     updated_at_min_year= django_filters.NumberFilter(field_name="updated_at__year" , lookup_expr="gte")
     updated_at_max_year= django_filters.NumberFilter(field_name="updated_at__year" , lookup_expr="lte")
     updated_at_min_month= django_filters.NumberFilter(field_name="updated_at__month" , lookup_expr="gte")
     updated_at_max_month= django_filters.NumberFilter(field_name="updated_at__month" , lookup_expr="lte")
     updated_at_min_day= django_filters.NumberFilter(field_name="updated_at__day" , lookup_expr="gte")
     updated_at_max_day= django_filters.NumberFilter(field_name="updated_at__day" , lookup_expr="lte")


     class Meta:
          model=ProductFeedback
          fields=["rating","created_at","updated_at","created_at_min_year","created_at_max_year","created_at_min_month",
                  "created_at_max_month","created_at_min_day","created_at_max_day"
                  ,"updated_at_min_year","updated_at_max_year","updated_at_min_month",
                  "updated_at_max_month","updated_at_min_day","updated_at_max_day"]

     def filter_queryset(self, queryset):
        queryset = super().filter_queryset(queryset) # you ensure that any default behavior or processing defined in the parent class is applied to the queryset before you perform any additional filtering or modifications in the child class.
        for field_name, value in self.data.items():
            # Exclude 'csrfmiddlewaretoken' and 'page' fields csrfmiddlewaretoken' or 'page'. These are typically internal fields generated by Django and are not relevant for filtering.
            if (field_name not in ['csrfmiddlewaretoken', 'page'] and field_name not in self.Meta.fields) or  not value: 
                    raise ValidationError("invaild url")  # If any field is empty or field name is wrong , return an empty queryset
            


            if self.data["rating"] :
                 if not (int(self.data["rating"]) >=0 and int(self.data["rating"])<=5) :
                      raise ValidationError ("Reating Should be from 1 to 5")

            
        return queryset
